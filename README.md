### **Проект "Synopsis": Спецификация**

#### **Часть I: Философия и Концепция**

**1. Видение:** Создать децентрализованную, саморегулируемую и прозрачную аналитическую среду для работы со знаниями. Цель — не дать один "правильный" ответ, а предоставить пользователям инструменты для критического сравнения различных, подтвержденных источниками точек зрения.

**2. Ключевые принципы:**
*   **Атомарность Контента:** Основа всего — **блок**, а не статья.
*   **Конкуренция Альтернатив:** Каждая смысловая единица (блок, свойство) существует в виде набора конкурирующих альтернатив.
*   **Обязательная Верификация:** Каждое изменение (коммит) требует привязки к внешнему источнику.
*   **Демократия и Репутация:** Сообщество определяет наиболее релевантные версии путем голосования, а вес голоса и права зависят от репутации (кармы) пользователя.
*   **Семантическая Связность:** Система "понимает" смысл контента через иерархическую, векторную систему концептов (тегов и свойств).

---

#### **Часть II: Архитектура и Техническая Реализация**

**1. Основная Архитектура: "Реактивный Воркер" с гибридной раздачей статики**

*   **Ядро Системы:** монорепа на nestjs разделенная на приложения, которое управляет всей логикой.
*   **Воркеры:** реагируют на события мгновенно, выполняя все ресурсоемкие задачи (генерация статики, AI-анализ) в фоновых очередях.
*   **Статика:** Логика рендеринга Markdown и сборки блоков реализована в виде единого модуля, который используется и Воркером при генерации статики, и на фронтенде при динамическом обновлении.
*   **Хранение Контента (Git):**
    *   **Локальные Репозитории:** Каждая статья хранится в отдельном bare Git-репозитории на локальном сервере (`/data/git/article-slug.git`). Это обеспечивает скорость и изоляцию.
    *   **Структура Файлов:** Внутри репозитория каждая альтернатива — это отдельный Markdown-файл (`ru/b001-heading.md`, `en/b002-academic.md`). Имя файла несет семантическую информацию.
    *   **Коммиты:** API создает коммиты от имени пользователя, включая URL-источник в сообщение коммита.
*   **Хранение Метаданных (PostgreSQL):**
    *   Единая база PostgreSQL служит "мозгом" системы.
    *   Хранит `users`, `votes`, `discussions`, `search_index` (с векторами через `pgvector`), а также единую иерархическую таблицу `concepts`.
*   **Резервное копирование (GitHub):**
    *   Воркер периодически (например, раз в час) асинхронно выполняет `git push` из локальных репозиториев в публичные репозитории на GitHub.
    *   **GitHub используется строго как публичное "зеркало" и бэкап**, а не как основная рабочая инфраструктура, чтобы не нарушать ToS и избежать рисков блокировки.

**2. Раздача Контента (Гибридный подход):**

*   **Инфраструктура:** На основном сервере поднят **MinIO** (S3-совместимое хранилище) и веб-сервер **Nginx**.
*   **Процесс:**
    1.  Воркер после обработки коммита генерирует артефакты (`index.html`, `manifest.json`) и загружает их вместе со всеми `.md` файлами в MinIO.
    2.  Nginx настроен на раздачу статики напрямую из MinIO, кешируя запросы. Это обеспечивает S3-совместимость для будущего масштабирования.
*   **"Гидратация":**
    *   Анонимные пользователи получают быструю статическую страницу.
    *   Для авторизованных пользователей JavaScript "на лету" подгружает с API актуальные данные (голоса, комментарии) и обновляет DOM.

---

#### **Часть III: Функциональные Модули**

**1. Концепты: Универсальная Семантическая Сеть**

В основе всей системы лежит единая иерархическая сущность — **"Концепт"**. Это позволяет отказаться от искусственного разделения на "теги", "свойства" и "значения", превращая всю базу знаний в единый, связанный граф.

*   **Принцип "Всё есть Концепт":** Любая мета-информация, будь то категория ("Наука"), свойство ("Дата рождения") или конкретное значение ("1995-08-28"), является равноправным узлом (концептом) в графе.
*   **Структура данных (Таблица `concepts` в PG):**
    *   `id`: Первичный ключ.
    *   `key`: Уникальный, машиночитаемый, не зависящий от языка ключ (`'birth-date'`, `'1995-08-28'`). Используется для URL, API и внутренних связей.
    *   `parent_id`: Ссылка на родительский концепт. Создает иерархию и обеспечивает контекст (например, у концепта `'1995-08-28'` родитель — `'date'`).
    *   `type`: Определяет роль концепта в интерфейсе (`'category'`, `'property'`, `'value'`).
    *   `vector`: Векторное представление (`pgvector`) для семантического поиска и нахождения связей.
*   **Связь со статьей:** Статьи и блоки не хранят значения, а лишь ссылаются на `id` нужных концептов через связующие таблицы (`article_concepts`, `block_concepts`).
*   **Мультиязычность (Таблица `concept_labels`):** Хранит человекочитаемые представления для каждого концепта на разных языках (`concept_id`, `lang_code`, `label`). Это позволяет системе оперировать стабильным `key`, отображая пользователю локализованный текст.

**2. "Карточка Феномена": Динамическая Витрина Концептов**

"Карточка Феномена" — это не отдельная сущность, а динамически генерируемый интерфейс, который визуализирует связи статьи с концептами типа `'property'` и `'value'`.

*   **Процесс генерации:**
    1.  Для отображения карточки статьи (например, "Альберт Эйнштейн") система запрашивает все связанные с ней концепты.
    2.  Она находит концепты-значения, например: `{ key: '1879-03-14', parent_id: 5 }`.
    3.  Используя `parent_id`, она находит родительский концепт-свойство: `{ id: 5, key: 'birth-date' }`.
    4.  На основе этой пары (`родитель-потомок`) система рендерит в интерфейсе строку: **"Дата рождения: 1879-03-14"**.
*   **Интерактивность и Голосование:**
    *   Каждая строка в карточке — это не просто текст. "Дата рождения" — это ссылка на страницу концепта `'birth-date'`, а "1879-03-14" — ссылка на страницу концепта `'1879-03-14'`, где будут перечислены все другие статьи с этой датой.
    *   **Альтернативы и голосование применяются к самой *связи*** между статьей и концептом-значением. Если кто-то хочет оспорить дату рождения Эйнштейна, он предлагает новую связь: `статья "Альберт Эйнштейн" -> концепт "1879-03-15"`. Сообщество голосует за то, какая из этих двух связей является основной.

**3. AI-подсистема (локальные, легковесные модели):**

*   **AI-ассистент:** Фоновый процесс анализирует слишком "широкие" концепты и предлагает модераторам разделить их на более точные дочерние.
*   **Embedding:** Используются локальные модели (например, из семейства Qwen) для векторизации контента и концептов.
*   **Распознавание Сущностей (NER):** Легковесная LLM анализирует текст блока, извлекает потенциальные сущности и предлагает пользователю превратить их в ссылки. Промпт: `"Найди в тексте '...' все феномены и верни JSON-массив их базовых форм"`.
*   **Верификация Источников:** AI-воркер асинхронно скачивает (`Playwright`) и анализирует источник, помечая блок результатом проверки.
*   **Автоматические перводы** AI-воркер автоматически переводит блок на разные языки. 

**4. Git API:**
*   Серверное приложение напрямую взаимодействует с локальными Git-репозиториями через библиотеки (`simple-git`) для получения истории, diff'ов и метаданных коммитов для отображения в интерфейсе. Внешний API не требуется.
Конечно. Давайте детализируем весь функционал клиентской части — то, с чем непосредственно взаимодействует пользователь. Я представлю это в виде таблицы, как вы и предложили, чтобы наглядно описать каждую функцию.

---

### **Часть IV: Пользовательский Опыт (UX) — Детализация Клиентской Части**

Клиентская часть (фронтенд) спроектирована как умный и быстрый "сборщик", который получает от сервера "конструктор" (статический HTML + манифест) и динамически собирает/обновляет его в браузере пользователя, минимизируя обращения к серверу.

| Функция | Пользователь (Кто?) | Действие (Как?) | Интерфейс (Что? Где?) | Техническая реализация (Под капотом) |
| :--- | :--- | :--- | :--- | :--- |
| **Просмотр статьи** | Любой пользователь | Вводит URL или переходит по ссылке. | **Где:** Основная контентная область.<br>**Что:** Загружается страница с "основной" версией статьи (собранной из блоков/альтернатив с наивысшим рейтингом). Текст чистый, легко читаемый. | Браузер мгновенно загружает с CDN/MinIO готовый `index.html` и `manifest.json`. Никаких запросов к API на этом этапе. |
| **Просмотр альтернатив** | Любой пользователь | Видит индикатор у блока, нажимает на него. | **Где:** Справа от каждого блока.<br>**Что:** Ненавязчивая иконка-счетчик `[+3]`. При клике открывается боковая панель (или модальное окно) со стопкой карточек. Каждая карточка — это одна альтернатива с текстом, ссылкой на источник и текущим счетом голосов. | `manifest.json` содержит пути ко всем `.md` файлам альтернатив. JS-сборщик по клику делает `fetch()` запросы только для тех файлов, которых еще нет в кеше, рендерит их в HTML с помощью изоморфного модуля и отображает в панели. |
| **Голосование** | Зарегистрированный пользователь | В панели альтернатив нажимает кнопку "Проголосовать" на понравившейся карточке. | **Где:** На каждой карточке альтернативы.<br>**Что:** Кнопка "Проголосовать" (▲). После нажатия она становится активной, а счетчик голосов обновляется. Голос можно изменить, нажав на кнопку у другой альтернативы. | Отправляется легковесный `POST` запрос на API (`/api/vote`) с `id` блока и `id` альтернативы. Ответ от API не требуется. Фронтенд оптимистично обновляет интерфейс (меняет цвет кнопки, инкрементирует счетчик), обеспечивая мгновенный отклик. |
| **Просмотр источника** | Любой пользователь | Нажимает на иконку источника у блока или альтернативы. | **Где:** На карточке альтернативы или рядом с отображаемым блоком.<br>**Что:** Иконка в виде скрепки или глобуса. При клике ссылка на источник открывается в новой вкладке. | Простое действие `<a>` тега со ссылкой, которая хранится в метаданных блока в `manifest.json` и была вставлена в DOM при рендеринге. |
| **Сплит-режим (Сравнение перспектив)** | Любой пользователь | 1. Нажимает кнопку "Сравнить".<br>2. В появившемся окне выбирает два концепта для сравнения.<br>3. Нажимает "Применить". | **Где:** Вверху статьи.<br>**Что:** Кнопка "Сравнить перспективы". Открывает модальное окно с двумя выпадающими списками ("Сторона 1", "Сторона 2"), которые заполнены основными концептами-категориями статьи. После применения страница перестраивается в двухколоночный вид. | 1. JS-сборщик берет два выбранных `concept.key`.<br>2. Проходит по всем слотам блоков в `manifest.json`.<br>3. Для каждой стороны и каждого слота находит наиболее подходящий файл (`.md`) с нужным тегом.<br>4. Делает `fetch()` всех необходимых файлов.<br>5. Полностью перерисовывает контентную область, собирая две версии статьи и размещая их в две колонки. **Всё происходит на клиенте.** |
| **Предложение новой альтернативы/блока** | Зарегистрированный пользователь | 1. Нажимает "Предложить альтернативу" у существующего блока или "+" между блоками.<br>2. Вводит текст в редакторе.<br>3. Вставляет URL-источник в обязательное поле.<br>4. Нажимает "Сохранить". | **Где:** В панели альтернатив или между блоками.<br>**Что:** Простой и понятный текстовый редактор (похожий на Notion/Medium). Обязательное поле для ссылки `[Источник]`. Кнопка "Опубликовать". | Отправляется `POST` запрос на API со всем содержимым. API создает новый коммит в Git, запускает фоновые воркеры. Фронтенд может оптимистично добавить новую альтернативу в список с пометкой "на проверке". |
| **Взаимодействие с AI-подсказками** | Зарегистрированный пользователь | Видит в тексте предложенную ссылку, наводит на нее и подтверждает/отклоняет. | **Где:** Прямо в тексте редактируемого блока.<br>**Что:** Слова, для которых AI нашел релевантные статьи, подсвечены пунктирной линией. При наведении появляется тултип: `Ссылка на статью "Физика"? [Да] [Нет]`. | Информация о предложенных ссылках подгружается асинхронно с API. При подтверждении отправляется запрос, который создает новый микро-коммит с добавлением разметки ссылки в `.md` файл. |
| **Навигация по концептам** | Любой пользователь | Нажимает на тег (концепт) под заголовком статьи или на свойство в "Карточке феномена". | **Где:** В шапке статьи или в "Карточке феномена".<br>**Что:** Все концепты являются кликабельными ссылками-плашками. | Обычный переход по ссылке (`<a>` тег) на страницу концепта, например, `/concepts/physics`. Эта страница является отдельным, так же статически сгенерированным, списком всех статей, связанных с данным концептом. |
| **Просмотр истории блока** | Любой пользователь | В панели альтернатив нажимает на иконку "История". | **Где:** На каждой карточке альтернативы или у основного блока.<br>**Что:** Иконка в виде часов. Открывает модальное окно со списком коммитов для этого блока. Можно выбрать два коммита для сравнения. | Делает запрос к API (`/api/git/history?file=...`). API, используя `simple-git`, отдает историю коммитов для данного файла. При выборе двух коммитов делается еще один запрос на получение `diff`, который красиво рендерится на фронтенде (показывая добавленный и удаленный текст). |
| **Поиск** | Любой пользователь | Вводит запрос в строку поиска. | **Где:** В шапке сайта, всегда доступна.<br>**Что:** Поисковая строка. По мере ввода появляются релевантные подсказки (статьи и концепты). На странице результатов поиска отображаются найденные статьи с краткими описаниями (сниппетами). | Запрос отправляется на API (`/api/search?q=...`). Бэкенд использует `pgvector` для семантического поиска по индексированным векторам блоков и концептов, а также полнотекстовый поиск. Возвращает отсортированный список ссылок на статические страницы. |
| **Обсуждение блока** | Зарегистрированный пользователь | 1. Нажимает на иконку обсуждения у блока.<br>2. Читает комментарии.<br>3. Пишет свой комментарий в форму и отправляет. | **Где:** Рядом с каждым блоком.<br>**Что:** Иконка в виде облачка с цифрой `[12]`. Открывает боковую панель (или разворачивает область под блоком) с древовидной структурой комментариев. | Комментарии не являются частью статики. При открытии обсуждения уходит `GET` запрос на `/api/discussions?block_id=...`. Отправка нового комментария — `POST` запрос. Интерфейс обновляется динамически, без перезагрузки страницы. |
| **Просмотр "Карточки Феномена"** | Любой пользователь | Смотрит на информационный блок в начале статьи. | **Где:** Вверху статьи, справа или под заголовком.<br>**Что:** Таблица или список ключевых свойств и их значений (`Дата рождения: 1879-03-14`). Каждое свойство и значение являются ссылками на соответствующие страницы концептов. | Рендерится на этапе статической сборки на основе связей статьи с концептами типа `'property'` и `'value'`. JavaScript может "гидрировать" эту карточку, подгружая альтернативные значения свойств. |
| **Редактирование "Карточки Феномена"** | Зарегистрированный пользователь | 1. Нажимает "Редактировать" у карточки.<br>2. Добавляет новое свойство (выбирая концепт из списка) или предлагает альтернативное значение для существующего. | **Где:** В режиме редактирования карточки.<br>**Что:** Интерфейс со списком текущих свойств. Кнопка `[+ Добавить свойство]`. У каждого значения есть кнопка `[Предложить альтернативу]`. | Отправляется `POST` запрос на API, который создает/изменяет связь между статьей и концептом-значением в PostgreSQL и создает соответствующий коммит в Git для логирования действия. |
| **Просмотр профиля пользователя** | Любой пользователь | Нажимает на имя пользователя (например, автора блока или комментария). | **Где:** Везде, где отображается имя пользователя.<br>**Что:** Открывается страница профиля с информацией о пользователе: его карма, значки-достижения, список самых популярных правок и созданных статей. | Страницы профилей могут быть как статически сгенерированными (обновляются раз в час), так и динамическими, запрашивающими данные с `/api/users/username` при загрузке. |
| **Управление концептами (для модераторов)** | Пользователь с высокой кармой | В специальном разделе "Управление" видит предложения AI по разделению тегов и утверждает/отклоняет их. | **Где:** Отдельная страница в личном кабинете.<br>**Что:** Список предложений вида: `Разделить концепт "Наука" на "Физика", "Химия", "Биология"? [Да] [Нет]`. | При утверждении на бэкенд уходит запрос, который создает новые концепты в таблице `concepts` и запускает фоновый воркер для пере-тегирования связанных статей. |
| **Интерактивный онбординг** | Новый пользователь | При первом входе система проводит его по основным действиям. | **Где:** Всплывающие подсказки и подсветка элементов интерфейса.<br>**Что:** Серия шагов: "Отлично! Теперь попробуйте проголосовать за эту альтернативу.", "А теперь предложите свою правку здесь." и т.д. | Чисто фронтенд-логика, реализованная с помощью библиотек типа `Shepherd.js` или `Intro.js`. Состояние прохождения онбординга хранится в профиле пользователя. |
| **Просмотр графа знаний** | Любой пользователь | Нажимает на кнопку "Граф связей" на странице статьи. | **Где:** Вверху или в боковой панели статьи.<br>**Что:** Открывается модальное окно или отдельная страница с интерактивной визуализацией. Текущая статья в центре, от нее идут связи к другим статьям и концептам. Узлы окрашены по семантической близости. | `manifest.json` может содержать базовую информацию о связях. Для полной интерактивности фронтенд делает запрос к API (`/api/graph?article=...`), который отдает данные для визуализации (с помощью `D3.js`, `vis.js` или аналогичных библиотек). |
| **Жалоба на контент** | Зарегистрированный пользователь | Нажимает на иконку "пожаловаться" у блока, альтернативы или комментария. | **Где:** В меню "..." рядом с каждым элементом контента.<br>**Что:** Иконка в виде флажка. Открывает окно с выбором причины жалобы (`Вандализм`, `Неверный источник`, `Оскорбление`). | `POST` запрос на `/api/report` с `id` контента и причиной. Создает задачу для модераторов в их интерфейсе. |
| **Обработка жалоб (Репортов)** | Модератор | 1. Переходит в раздел "Жалобы".<br>2. Видит список жалоб, отсортированных по срочности/количеству.<br>3. Выбирает жалобу, видит контекст (блок, комментарий) и причину.<br>4. Принимает решение: "Отклонить жалобу" или "Принять меры". | **Где:** Отдельная страница "Панель модератора" -> "Жалобы".<br>**Что:** Интерфейс в виде очереди задач. Каждая задача — это карточка с жалобой. Кнопки действий: `[Отклонить]`, `[Скрыть контент]`, `[Наказать пользователя]`. | `GET` запрос к `/api/reports` для получения списка. `POST` запрос к `/api/reports/resolve` для выполнения действия. Действие (например, скрытие) меняет флаг у контента в БД, а наказание обновляет профиль пользователя. |
| **Управление пользователями** | Модератор/Администратор | 1. Находит пользователя через поиск в панели.<br>2. Просматривает его историю действий.<br>3. Может временно ограничить его права (например, запретить редактирование на 7 дней) или повысить/понизить карму вручную. | **Где:** "Панель модератора" -> "Пользователи".<br>**Что:** Поиск пользователей. Профиль пользователя с детальным логом всех его коммитов, голосов, комментариев. Кнопки: `[Ограничить права]`, `[Изменить карму]`. | `POST` запросы к API (`/api/users/moderate`), которые требуют специальных прав. Изменяют поля в таблице `users` (например, `restrictions_until`, `karma`). |
| **"Заморозка" блока/статьи** | Модератор | Видя "войну правок" на особо спорной теме, нажимает кнопку "Заморозить". | **Где:** В меню "..." у блока или в шапке статьи.<br>**Что:** Кнопка `[❄️ Заморозить]`. Открывает окно с выбором срока заморозки (1 час, 1 день, до ручной разморозки). | API-запрос, который ставит в БД флаг `is_frozen: true` для блока или всех блоков статьи. API будет отклонять любые попытки коммитов для замороженного контента, пока флаг не будет снят. |
| **Слияние дублирующихся концептов** | Модератор | 1. В панели управления концептами видит список потенциальных дублей (найденных AI по семантической близости).<br>2. Выбирает два концепта (например, "ИИ" и "Искусственный интеллект").<br>3. Указывает, какой из них главный, и нажимает "Слить". | **Где:** "Панель модератора" -> "Концепты".<br>**Что:** Интерфейс, похожий на `git merge`. Показывает два концепта и спрашивает, какой из них оставить. | Сложный `POST` запрос на `/api/concepts/merge`. Бэкенд запускает транзакцию в PostgreSQL: перепривязывает все статьи/блоки от старого `concept_id` к новому, удаляет старый концепт, обновляет лейблы. |
| **Просмотр системных метрик** | Администратор | Переходит в раздел "Аналитика". | **Где:** "Панель администратора" -> "Дашборд".<br>**Что:** Графики и цифры: количество новых пользователей/статей/правок за день/неделю/месяц, самые активные участники, самые спорные статьи (по частоте смены основного блока). | Динамическая страница, которая запрашивает агрегированные данные с специальных эндпоинтов API (`/api/analytics/overview`). Бэкенд выполняет сложные SQL-запросы для агрегации данных из таблиц `users`, `votes` и логов коммитов. |
| **Ручное управление AI-задачами** | Модератор/Администратор | В панели видит задачи, которые AI не смог выполнить (например, не удалось скачать источник), и может перезапустить их или отменить. | **Где:** "Панель модератора" -> "AI-Воркеры".<br>**Что:** Список фоновых задач с их статусами (`в очереди`, `выполняется`, `ошибка`). Кнопки `[Перезапустить]`, `[Отменить]`. | Интерфейс, который напрямую взаимодействует с системой управления очередями (например, `BullMQ Dashboard`). Позволяет управлять состоянием фоновых задач. |
| **Получение достижений (Ачивок)** | Любой зарегистрированный пользователь | Просто активно участвует в жизни платформы. | **Где:** В профиле пользователя.<br>**Что:** Внезапное уведомление `[✨ Получено достижение: "Первопроходец" (создал первую статью)]`. В профиле появляется галерея значков. | Воркер после каждого значимого действия пользователя (первый коммит, 100 голосов, победа в "войне правок") проверяет, не выполнил ли пользователь условия для получения нового достижения. Если да — добавляет запись в таблицу `user_achievements`. |
| **Создание новой статьи** | Любой зарегистрированный пользователь | 1. Вводит в поиске название, которого еще нет.<br>2. Система говорит: "Такой страницы нет" и предлагает создать.<br>3. Нажимает "Создать".<br>4. Опционально: нажимает "Сгенерировать черновик с помощью AI". | **Где:** Страница результатов поиска или специальная кнопка `[+ Новая статья]`.<br>**Что:** Чистая страница с полем для заголовка и кнопкой для AI-генерации "рыбы" статьи. | API-запрос на создание нового Git-репозитория и записи в таблице статей. Нажатие на кнопку AI-генерации ставит задачу в очередь для соответствующего воркера. |
| **Персонализированный Фид ("Лента")** | Зарегистрированный пользователь | Переходит на главную страницу после авторизации. | **Где:** Главная страница сайта (для залогиненных пользователей).<br>**Что:** Бесконечная лента карточек, похожая на ленту соцсетей. Каждая карточка — это событие: "Появилась новая популярная альтернатива в статье X", "Началось активное обсуждение под блоком Y", "Пользователь Z, на которого вы подписаны, создал новую статью". | **Сложнейшая, но ключевая функция:**<br>1. Бэкенд асинхронно вычисляет "вектор интересов" пользователя. Он **не усредняет** векторы понравившихся блоков, а создает **кластеры векторов** по основным концептам, за которые голосовал пользователь.<br>2. При запросе ленты система ищет недавние события (новые блоки, комментарии), векторы которых **близки к центроидам кластеров интересов** пользователя.<br>3. В ленту также подмешиваются события от авторов/концептов, на которые пользователь подписан, и самые горячие обсуждения. |
| **Подписки** | Зарегистрированный пользователь | 1. На странице пользователя нажимает "Подписаться".<br>2. На странице концепта нажимает "Отслеживать". | **Где:** На странице профиля пользователя и на странице концепта.<br>**Что:** Кнопка `[+ Подписаться]`. После подписки все значимые действия этого пользователя (создание статей, популярные правки) или события, связанные с концептом, будут появляться в ленте с более высоким приоритетом. | Простое действие, добавляющее запись в таблицы `user_subscriptions` (`follower_id`, `followed_id`) или `concept_subscriptions` (`user_id`, `concept_id`). |
| **Профиль пользователя (Расширенный)** | Любой пользователь | Переходит на страницу профиля. | **Где:** Профиль пользователя.<br>**Что:** Помимо кармы и достижений, появляются вкладки: **"Активность"** (лента действий пользователя), **"Созданные статьи"**, **"Подписки"** и **"Облако интересов"** (визуализация концептов, с которыми пользователь больше всего взаимодействует). | "Облако интересов" генерируется на основе анализа связей пользователя с концептами в БД. Чем больше взаимодействий (голосов, правок) с концептом, тем крупнее он в облаке. |
| **Уведомления** | Зарегистрированный пользователь | Видит индикатор новых уведомлений. | **Где:** Иконка колокольчика в шапке сайта.<br>**Что:** Выпадающий список с уведомлениями: "Ваш комментарий получил ответ", "Предложенная вами альтернатива победила в голосовании!", "Пользователь X подписался на вас". | Система событий на бэкенде. Действия (новый комментарий, голос за альтернативу) создают записи в таблице `notifications`. Фронтенд периодически опрашивает API (`/api/notifications/unread`) или использует WebSocket для получения уведомлений в реальном времени. |
| **Коллекции (Плейлисты знаний)** | Зарегистрированный пользователь | 1. На странице статьи нажимает "Добавить в коллекцию".<br>2. Создает новую коллекцию (например, "Материалы для диплома") или добавляет в существующую.<br>3. Может поделиться ссылкой на коллекцию. | **Где:** Меню "..." у статьи, страница профиля -> "Коллекции".<br>**Что:** Возможность группировать статьи по темам. Коллекции могут быть приватными или публичными. | Создаются таблицы `collections` (`id`, `user_id`, `title`, `is_public`) и `collection_articles` (`collection_id`, `article_id`). Публичные коллекции — это еще один тип контента, который может появляться в ленте. |
| **Команды/Рабочие группы** | Зарегистрированный пользователь | Создает команду, приглашает других пользователей. | **Где:** Отдельный раздел "Команды".<br>**Что:** Закрытое или открытое пространство для группы пользователей. Внутри команды — свой мини-фид, список статей, над которыми ведется совместная работа, и внутреннее обсуждение. Полезно для студентов, исследовательских групп, корпоративных баз знаний. | Вводит сущности `teams` и `team_members`. Фильтрация контента и фида происходит с учетом принадлежности пользователя к команде. Позволяет создавать приватные статьи, видимые только членам команды. |
| **"Дуэли" блоков** | Любой пользователь | На специальной странице видит два альтернативных блока на одну и ту же тему и голосует за лучший. | **Где:** Отдельная страница "Дуэли" или виджет на главной.<br>**Что:** Геймифицированный интерфейс, где система подбирает два примерно равных по силе, но противоположных по смыслу блока и предлагает пользователям решить, какой из них убедительнее. | Бэкенд-воркер ищет блоки с примерно одинаковым количеством голосов, но разными (семантически противоположными) векторами. Это вовлекает пользователей в процесс голосования и помогает "разморозить" спорные темы. |

---

### Техническая реализация: реактивный воркер и монорепа (Task 001)

**Структура монорепы**

- `apps/app` — ядро, предоставляет эндпоинт `/status` со сводкой по очереди и зарегистрированным воркерам.
- `apps/gateway` — HTTP-шлюз для постановки задач рендера, AI-анализов и других фоновых операций.
- `apps/worker-ai` — реактивный воркер для анализа источников; использует общую очередь и модуль Markdown.
- `apps/worker-git` — воркер для зеркалирования git-коммитов, работает с in-memory клиентом Git.
- `apps/frontend` — сервис рендеринга, переиспользует Markdown-движок и выдаёт манифест/HTML.
- `libs/shared-kernel` — общие DTO, очередь задач, клиенты Git/MinIO/PostgreSQL и Markdown-рендерер.
- `libs/rendering` — модуль для сборки манифестов и гидратации, переиспользуемый фронтендом и воркерами.

**Очередь задач**

Очередь реализована в `TaskQueueService` (RxJS). Приложения формируют сообщения через `SharedKernelService` и публикуют их напрямую в `TaskQueueService`. Воркеры регистрируются через `TaskQueueService.consume(...)` и автоматически снимаются с обработки при остановке. Ошибки попадают в стрим `errors()` и фиксируются ядром.

Отдельный `Domains`-модуль более не используется: bounded context-и будут раскладываться поверх общей очереди и сервисов `shared-kernel`, а межсервисные сообщения доставляются напрямую (через NATS/стандартный брокер) без дополнительной прослойки.

**Инфраструктура**

- `docker-compose.yml` поднимает PostgreSQL, Redis/BullMQ, MinIO и все Node-сервисы.
- `.env.example` описывает переменные окружения для всех приложений.

**Запуск**

```bash
cd app
npm install
npm run test     # прогон unit + e2e
# или поднять всю связку
cd ..
docker compose up --build
```

Для локальной разработки доступны отдельные скрипты `npm run start:gateway`, `npm run start:worker:ai`, `npm run start:worker:git`, `npm run start:frontend`.

**Тесты**

Каждое приложение имеет unit и e2e тесты (Jest + Supertest), проверяющие эндпоинты и работу очереди.
